{
  "name": "Agent Dispatcher",
  "description": null,
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "seconds",
              "secondsInterval": 60
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        250,
        300
      ],
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "command": "#!/bin/bash\n# Agent Dispatcher v4.2 \u2014 cursor-based idle detection\n# - Nudges premature idle agents with job-type-aware max nudges\n# - Idle detection: uses tmux cursor position instead of text parsing\n#   (immune to status bar wrapping and UI changes)\n\ngit config --global --add safe.directory '*' 2>/dev/null\n\n# \u2014\u2014 Helper: check if agent is idle via tmux \u2014\u2014\n# Returns: \"idle\", \"busy\", or \"no_session\"\n# Strategy: use tmux cursor position. When Claude Code is idle at its\n# prompt, the cursor sits on the \u276f line. When busy, cursor is on\n# whatever output/spinner is being rendered. This is a terminal-level\n# property immune to status bar wrapping and UI changes.\ncheck_idle() {\n  local NAME=\"$1\"\n  # Get cursor Y position within the visible pane\n  local CURSOR_Y\n  CURSOR_Y=$(su - agent -c \"tmux display-message -t '$NAME' -p '#{cursor_y}'\" 2>/dev/null) || { echo \"no_session\"; return; }\n  # Capture only the line where the cursor sits\n  local CURSOR_LINE\n  CURSOR_LINE=$(su - agent -c \"tmux capture-pane -p -t '$NAME' -S $CURSOR_Y -E $CURSOR_Y\" 2>/dev/null)\n  # Claude Code idle prompt starts with \u276f\n  if echo \"$CURSOR_LINE\" | grep -qE '^\u276f'; then\n    echo \"idle\"\n  else\n    echo \"busy\"\n  fi\n}\n\n# \u2014\u2014 Helper: send text to agent via tmux (temp file avoids all quoting issues) \u2014\u2014\nsend_to_agent() {\n  local NAME=\"$1\"\n  local TEXT=\"$2\"\n  local TMP=\"/tmp/.dispatch-msg-$$\"\n  printf '%s' \"$TEXT\" > \"$TMP\"\n  chmod 644 \"$TMP\"\n  su - agent -c \"tmux load-buffer '$TMP' && tmux paste-buffer -t '$NAME' -d && tmux send-keys -t '$NAME' Enter\" 2>/dev/null\n  rm -f \"$TMP\"\n}\n\n# \u2014\u2014 Helper: get agent's current working directory from AI Maestro \u2014\u2014\nget_agent_workdir() {\n  local AGENT_ID=\"$1\"\n  curl -s \"http://localhost:23001/api/agents/$AGENT_ID\" | python3 -c \"import sys,json; print(json.load(sys.stdin).get('workingDirectory',''))\" 2>/dev/null\n}\n\n# \u2014\u2014 Section 1: Check active jobs for completion \u2014\u2014\nfor AGENT_DIR in /data/queue/boswell-hub-manager /data/queue/boswell-app-manager; do\n  export AGENT_NAME=$(basename \"$AGENT_DIR\")\n  export ACTIVE_FILE=\"$AGENT_DIR/.active\"\n  [ ! -f \"$ACTIVE_FILE\" ] && continue\n\n  # Skip completion check if job started less than 2 minutes ago\n  AGE_OK=$(python3 -c \"\nimport json, os\nfrom datetime import datetime, timezone\na = json.load(open(os.environ['ACTIVE_FILE']))\ns = datetime.fromisoformat(a['started_at'].replace('Z', '+00:00'))\nprint('yes' if (datetime.now(timezone.utc) - s).total_seconds() > 120 else 'no')\n\")\n  if [ \"$AGE_OK\" = \"no\" ]; then\n    echo \"WAIT: $AGENT_NAME job too recent, skipping completion check\"\n    continue\n  fi\n\n  STATUS=$(check_idle \"$AGENT_NAME\")\n\n  if [ \"$STATUS\" = \"idle\" ] || [ \"$STATUS\" = \"no_session\" ]; then\n    # Check if this is premature idle \u2014 agent may have stopped before finishing\n    SHOULD_NUDGE=\"no\"\n    if [ \"$STATUS\" = \"idle\" ]; then\n      SHOULD_NUDGE=$(python3 -c \"\nimport json, os\nfrom datetime import datetime, timezone\na = json.load(open(os.environ['ACTIVE_FILE']))\ns = datetime.fromisoformat(a['started_at'].replace('Z', '+00:00'))\nelapsed = (datetime.now(timezone.utc) - s).total_seconds()\naction = a.get('action', '')\nnudges = a.get('nudge_count', 0)\n# Min expected duration (seconds) and max nudges per job type\n# Max nudges per job type (0 = never nudge, just mark complete)\nmax_nudges_map = {\n    'implement': 5,\n    'spec':      2,\n    'comment':   1,\n}\nmax_n = max_nudges_map.get(action, 0)\nif nudges < max_n:\n    print('yes')\nelse:\n    print('no')\n\")\n    fi\n\n    if [ \"$SHOULD_NUDGE\" = \"yes\" ]; then\n      # Agent went idle too early \u2014 nudge it to continue the current task\n      # Action-aware nudge message: spec nudges must NOT trigger /dev-start\n      ACTIVE_ACTION=$(python3 -c \"import json,os; print(json.load(open(os.environ['ACTIVE_FILE'])).get('action',''))\")\n      if [ \"$ACTIVE_ACTION\" = \"spec\" ]; then\n        NUDGE_MSG=\"You stopped before finishing the spec. Continue writing the specification and update the issue body. Do NOT proceed to implementation or run /dev-start.\"\n      else\n        NUDGE_MSG=\"You stopped before finishing. Continue working on the current task. Do not start new tasks.\"\n      fi\n      send_to_agent \"$AGENT_NAME\" \"$NUDGE_MSG\"\n      # Increment nudge count in .active file\n      python3 -c \"\nimport json, os\npath = os.environ['ACTIVE_FILE']\na = json.load(open(path))\na['nudge_count'] = a.get('nudge_count', 0) + 1\nwith open(path, 'w') as f:\n    json.dump(a, f)\nprint(f'NUDGE: {os.environ[\\\"AGENT_NAME\\\"]} went idle early (nudge #{a[\\\"nudge_count\\\"]})')\n\"\n    else\n      # Agent genuinely finished \u2014 post completion comment, remove .active\n      # DO NOT kill the session. Leave it idle for fast re-dispatch.\n      python3 << 'PYEOF'\nimport json, urllib.request, os\nfrom datetime import datetime, timezone\n\nactive = json.load(open(os.environ['ACTIVE_FILE']))\nnow = datetime.now(timezone.utc)\nstart = datetime.fromisoformat(active['started_at'].replace('Z', '+00:00'))\ndur = int((now - start).total_seconds() / 60)\nnudges = active.get('nudge_count', 0)\n\nnudge_note = f\" ({nudges} nudge{'s' if nudges != 1 else ''})\" if nudges > 0 else \"\"\n\nbody = \"\\n\".join([\n    f\"\\U0001f916 **{os.environ['AGENT_NAME']}** finished working on this issue.\",\n    \"\",\n    f\"**Task:** {active['action']} \\u00b7 **Issue:** #{active['issue_number']}\",\n    f\"**Started:** {start.strftime('%Y-%m-%d %H:%M UTC')}\",\n    f\"**Completed:** {now.strftime('%Y-%m-%d %H:%M UTC')} \\u00b7 Duration: {dur}m{nudge_note}\",\n    \"**Status:** \\u2705 Complete\",\n])\n\ndata = json.dumps({\"body\": body}).encode()\nreq = urllib.request.Request(\n    f\"https://api.github.com/repos/{active['repo']}/issues/comments/{active['comment_id']}\",\n    data=data, method='PATCH',\n    headers={\n        'Authorization': f\"token {os.environ.get('GH_TOKEN', '')}\",\n        'Accept': 'application/vnd.github+json',\n        'Content-Type': 'application/json',\n    }\n)\ntry:\n    urllib.request.urlopen(req)\n    os.remove(os.environ['ACTIVE_FILE'])\n    print(f\"COMPLETE: {os.environ['AGENT_NAME']} #{active['issue_number']} ({active['action']}) - {dur}m{nudge_note}\")\nexcept Exception as e:\n    print(f\"ERROR updating comment: {e}\")\nPYEOF\n    fi\n\n  elif [ \"$STATUS\" = \"busy\" ]; then\n    # Check if stuck (>2h)\n    export ACTIVE_FILE AGENT_NAME\n    python3 << 'PYEOF'\nimport json, urllib.request, os\nfrom datetime import datetime, timezone\n\nactive = json.load(open(os.environ['ACTIVE_FILE']))\nstart = datetime.fromisoformat(active['started_at'].replace('Z', '+00:00'))\nelapsed = (datetime.now(timezone.utc) - start).total_seconds()\n\nif elapsed > 7200:\n    body = \"\\n\".join([\n        f\"\\U0001f916 **{os.environ['AGENT_NAME']}** is working on this issue.\",\n        \"\",\n        f\"**Task:** {active['action']} \\u00b7 **Issue:** #{active['issue_number']}\",\n        f\"**Started:** {start.strftime('%Y-%m-%d %H:%M UTC')}\",\n        f\"**Status:** \\u26a0\\ufe0f Agent may be stuck (>{int(elapsed/3600)}h)\",\n    ])\n    data = json.dumps({\"body\": body}).encode()\n    req = urllib.request.Request(\n        f\"https://api.github.com/repos/{active['repo']}/issues/comments/{active['comment_id']}\",\n        data=data, method='PATCH',\n        headers={\n            'Authorization': f\"token {os.environ.get('GH_TOKEN', '')}\",\n            'Accept': 'application/vnd.github+json',\n            'Content-Type': 'application/json',\n        }\n    )\n    try:\n        urllib.request.urlopen(req)\n        print(f\"WARN: {os.environ['AGENT_NAME']} stuck (>{int(elapsed/3600)}h)\")\n    except Exception as e:\n        print(f\"ERROR: {e}\")\nPYEOF\n  fi\ndone\n\n# \u2014\u2014 Section 2: Dispatch new jobs \u2014\u2014\nfor AGENT_DIR in /data/queue/boswell-hub-manager /data/queue/boswell-app-manager; do\n  AGENT_NAME=$(basename \"$AGENT_DIR\")\n  ACTIVE_FILE=\"$AGENT_DIR/.active\"\n\n  # Skip if agent has active work\n  [ -f \"$ACTIVE_FILE\" ] && continue\n\n  # Get oldest job file (timestamp prefix = FIFO)\n  OLDEST=$(ls -1 \"$AGENT_DIR\"/ 2>/dev/null | grep -v '^\\.' | sort | head -1)\n  [ -z \"$OLDEST\" ] && continue\n\n  # Read job file\n  JOB=$(cat \"$AGENT_DIR/$OLDEST\")\n  MESSAGE=$(echo \"$JOB\" | python3 -c \"import sys,json; print(json.load(sys.stdin)['message'])\")\n  ISSUE_NUM=$(echo \"$JOB\" | python3 -c \"import sys,json; print(json.load(sys.stdin)['issue_number'])\")\n  NEEDS_WT=$(echo \"$JOB\" | python3 -c \"import sys,json; print(json.load(sys.stdin)['needs_worktree'])\")\n  JOB_REPO=$(echo \"$JOB\" | python3 -c \"import sys,json; print(json.load(sys.stdin)['repo'])\")\n  JOB_ACTION=$(echo \"$JOB\" | python3 -c \"import sys,json; print(json.load(sys.stdin)['action'])\")\n\n  AGENT_ROOT=\"/data/agents/$AGENT_NAME\"\n  REPO=\"$AGENT_ROOT/repo\"\n  WT_PATH=\"$AGENT_ROOT/issues/issue-$ISSUE_NUM\"\n\n  # Freshness: reset repo to default branch, fetch + pull\n  git -C \"$REPO\" checkout master 2>/dev/null || git -C \"$REPO\" checkout main 2>/dev/null || true\n  git -C \"$REPO\" fetch origin 2>&1 || echo \"WARN: git fetch failed for $AGENT_NAME\"\n  git -C \"$REPO\" pull --ff-only 2>/dev/null || true\n\n  # Issue workspace setup: always fresh clone per dispatch\n  if [ \"$NEEDS_WT\" = \"True\" ] || [ \"$NEEDS_WT\" = \"true\" ]; then\n    rm -rf \"$WT_PATH\"\n    GITHUB_URL=$(git -C \"$REPO\" remote get-url origin)\n    CLONE_OUT=$(git clone \"$REPO\" \"$WT_PATH\" 2>&1)\n    CLONE_RC=$?\n    if [ $CLONE_RC -ne 0 ]; then\n      echo \"ERROR: clone failed for $AGENT_NAME issue-$ISSUE_NUM: $CLONE_OUT\"\n      continue\n    fi\n    git -C \"$WT_PATH\" remote set-url origin \"$GITHUB_URL\"\n    git -C \"$WT_PATH\" fetch origin 2>&1\n    # Detect default branch from remote\n    DEFAULT_BRANCH=$(git -C \"$WT_PATH\" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|refs/remotes/origin/||')\n    [ -z \"$DEFAULT_BRANCH\" ] && DEFAULT_BRANCH=\"master\"\n    # Checkout existing issue branch from remote, or create new one from default\n    git -C \"$WT_PATH\" checkout \"issue/$ISSUE_NUM\" 2>/dev/null || \\\n      git -C \"$WT_PATH\" checkout -b \"issue/$ISSUE_NUM\" \"origin/$DEFAULT_BRANCH\" 2>&1\n    BRANCH_CHECK=$(git -C \"$WT_PATH\" rev-parse --abbrev-ref HEAD)\n    if [ \"$BRANCH_CHECK\" = \"master\" ] || [ \"$BRANCH_CHECK\" = \"main\" ]; then\n      echo \"ERROR: branch checkout failed for $AGENT_NAME issue-$ISSUE_NUM (still on $BRANCH_CHECK)\"\n      rm -rf \"$WT_PATH\"\n      continue\n    fi\n    rm -rf \"$WT_PATH/.claude/work\" 2>/dev/null\n    git -C \"$WT_PATH\" config --local gh.default-repo \"$JOB_REPO\" 2>/dev/null\n    su - agent -c \"cd '$WT_PATH' && gh repo set-default '$JOB_REPO'\" 2>/dev/null || true\n    cat >> \"$WT_PATH/CLAUDE.md\" << 'GUARDRAILS'\n\n## Agent Guardrails (auto-injected by dispatcher)\n\n- **NEVER create or switch branches.** Work on whatever branch you are on when the session starts.\n- **If you are on main or master, STOP.** Do not proceed \u2014 report the error and exit.\n- **NEVER merge pull requests.** Only create PRs and leave them for human review.\n- **NEVER close or resolve issues.** Only reference them in PR descriptions.\n- **This repository is: REPO_PLACEHOLDER.** Always use `--repo REPO_PLACEHOLDER` with gh CLI commands, or omit --repo to use the configured default.\nGUARDRAILS\n    sed -i \"s|REPO_PLACEHOLDER|$JOB_REPO|g\" \"$WT_PATH/CLAUDE.md\"\n    chown -R agent:agent \"$WT_PATH\"\n    # boswell-hub issue clones: write master.key, enable dev caching, patch database.yml\n    if [ \"$AGENT_NAME\" = \"boswell-hub-manager\" ] && [ -n \"$BOSWELL_HUB_MASTER_KEY\" ]; then\n      echo -n \"$BOSWELL_HUB_MASTER_KEY\" > \"$WT_PATH/config/master.key\"\n      chmod 600 \"$WT_PATH/config/master.key\"\n      chown agent:agent \"$WT_PATH/config/master.key\"\n      mkdir -p \"$WT_PATH/tmp\"\n      touch \"$WT_PATH/tmp/caching-dev.txt\"\n      sed -i 's|/Users/brandoncasci/.asdf/installs/postgres/12.1/sockets|/var/run/postgresql|g' \"$WT_PATH/config/database.yml\"\n    fi\n    WORK_DIR=\"$WT_PATH\"\n  elif [ \"$NEEDS_WT\" = \"if_exists\" ] && [ -d \"$WT_PATH\" ]; then\n    WORK_DIR=\"$WT_PATH\"\n  else\n    git -C \"$REPO\" pull 2>&1 || true\n    WORK_DIR=\"$REPO\"\n  fi\n\n  # Get agent ID from AI Maestro registry\n  AGENT_ID=$(python3 -c \"\nimport json\nwith open('/data/ai-maestro/agents/registry.json') as f:\n    agents = json.load(f)\nfor a in agents:\n    if a['name'] == '$AGENT_NAME':\n        print(a['id'])\n        break\n\")\n\n  if [ -z \"$AGENT_ID\" ]; then\n    echo \"ERROR: No agent ID found for $AGENT_NAME\"\n    continue\n  fi\n\n  # \u2014\u2014 Dispatch: check session state and send work \u2014\u2014\n  SESSION_STATUS=$(check_idle \"$AGENT_NAME\")\n  CURRENT_DIR=$(get_agent_workdir \"$AGENT_ID\")\n  NEED_RESTART=false\n\n  if [ \"$SESSION_STATUS\" = \"busy\" ]; then\n    echo \"SKIP: $AGENT_NAME busy, will retry next cycle\"\n    continue\n  fi\n\n  if [ \"$SESSION_STATUS\" = \"idle\" ]; then\n    # Agent is running and idle \u2014 check if working directory matches\n    if [ \"$CURRENT_DIR\" = \"$WORK_DIR\" ]; then\n      # Same directory: /clear and send command. Fast path.\n      echo \"FAST: $AGENT_NAME idle, same dir \u2014 /clear + send\"\n      send_to_agent \"$AGENT_NAME\" \"/clear\"\n      sleep 5\n      send_to_agent \"$AGENT_NAME\" \"$MESSAGE\"\n    else\n      # Different directory: need to restart with new CWD\n      echo \"RESTART: $AGENT_NAME idle but dir changed ($CURRENT_DIR -> $WORK_DIR)\"\n      NEED_RESTART=true\n      su - agent -c \"tmux kill-session -t '$AGENT_NAME'\" 2>/dev/null || true\n      sleep 2\n    fi\n  else\n    # No session at all\n    NEED_RESTART=true\n  fi\n\n  if [ \"$NEED_RESTART\" = \"true\" ]; then\n    # Kill any existing session (runs as agent to access agent's tmux)\n    su - agent -c \"tmux kill-session -t '$AGENT_NAME'\" 2>/dev/null || true\n    sleep 2\n    # Set working directory, wake, wait for init, send command\n    curl -s -X PATCH \"http://localhost:23001/api/agents/$AGENT_ID\" \\\n      -H \"Content-Type: application/json\" \\\n      -d \"{\\\"workingDirectory\\\": \\\"$WORK_DIR\\\"}\" > /dev/null\n    curl -s -X POST \"http://localhost:23001/api/agents/$AGENT_ID/wake\" > /dev/null\n    echo \"WAKE: $AGENT_NAME \u2014 waiting 35s for init...\"\n    sleep 35\n    # Send command directly via tmux (bypass flaky API idle check)\n    send_to_agent \"$AGENT_NAME\" \"$MESSAGE\"\n  fi\n\n  # Remove job from queue\n  rm \"$AGENT_DIR/$OLDEST\"\n\n  # Post start comment on GitHub + write .active file\n  export AGENT_NAME ISSUE_NUM JOB_REPO JOB_ACTION ACTIVE_FILE\n  python3 << 'PYEOF'\nimport json, urllib.request, os\nfrom datetime import datetime, timezone\n\nnow = datetime.now(timezone.utc)\nnow_str = now.strftime('%Y-%m-%d %H:%M UTC')\nagent = os.environ['AGENT_NAME']\nissue = os.environ['ISSUE_NUM']\nrepo = os.environ['JOB_REPO']\naction = os.environ['JOB_ACTION']\n\nbody = \"\\n\".join([\n    f\"\\U0001f916 **{agent}** is working on this issue.\",\n    \"\",\n    f\"**Task:** {action} \\u00b7 **Issue:** #{issue}\",\n    f\"**Started:** {now_str}\",\n    \"**Status:** \\u23f3 In progress...\",\n])\n\ndata = json.dumps({\"body\": body}).encode()\nreq = urllib.request.Request(\n    f\"https://api.github.com/repos/{repo}/issues/{issue}/comments\",\n    data=data, method='POST',\n    headers={\n        'Authorization': f\"token {os.environ.get('GH_TOKEN', '')}\",\n        'Accept': 'application/vnd.github+json',\n        'Content-Type': 'application/json',\n    }\n)\ntry:\n    resp = urllib.request.urlopen(req)\n    comment = json.loads(resp.read())\n    comment_id = comment['id']\n\n    active_data = {\n        'comment_id': comment_id,\n        'issue_number': int(issue),\n        'repo': repo,\n        'action': action,\n        'started_at': now.isoformat().replace('+00:00', 'Z'),\n        'nudge_count': 0,\n    }\n    with open(os.environ['ACTIVE_FILE'], 'w') as f:\n        json.dump(active_data, f)\n\n    print(f\"STARTED: {agent} #{issue} ({action}) - comment {comment_id}\")\nexcept Exception as e:\n    print(f\"ERROR posting start comment: {e}\")\nPYEOF\n\n  echo \"OK: Dispatched to $AGENT_NAME (issue #$ISSUE_NUM, dir=$WORK_DIR): $(echo \"$MESSAGE\" | head -c 100)\"\ndone\n"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        520,
        300
      ],
      "name": "Dispatch Work"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Dispatch Work",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}